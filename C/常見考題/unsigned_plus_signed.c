以下是 `.md` 版本的內容：  

```md
# C 語言 `unsigned int` 和 `int` 運算問題解析

## **1. 代碼解析**
```c
#include <stdio.h>

void foo(void) {
    unsigned int a = 6;  // a 是無符號整數 (unsigned int)
    int b = -20;         // b 是有符號整數 (int)

    (a + b > 6) ? puts("> 6") : puts("<= 6");
}
```

### **關鍵點**
- `a` 是 **無符號整數 (`unsigned int`)**，值為 `6`。
- `b` 是 **有符號整數 (`int`)**，值為 `-20`。
- `a + b` 這個運算中，`b` 會被 **隱式轉換為 `unsigned int`**。
- `-20` 轉換為 `unsigned int` 會導致 **整數溢出**，因為 `unsigned int` 無法表示負數。

---

## **2. `b` 轉換為 `unsigned int`**
在 C 語言中，當 **有符號數 (`int`) 和無符號數 (`unsigned int`) 參與運算時，`int` 會被提升為 `unsigned int`**。

### **步驟分析**
1. `b = -20` 在 `int` 中的 **二進制補碼表示**（假設 `int` 為 32 位）：
   ```yaml
   1111 1111 1111 1111 1111 1111 1110 1100   // 即 -20 的補碼表示
   ```
2. 當 `b` 被轉換為 `unsigned int`，其值變為：
   ```go
   4294967276 (即 `2^32 - 20`)
   ```
   **這是一個非常大的數**。

3. 計算 `a + b`：
   ```c
   a + b = 6 + 4294967276 = 4294967282  (超大正數)
   ```
   這個結果遠遠大於 `6`，因此 `(a + b > 6)` 判斷為 `true`，執行：
   ```c
   puts("> 6");
   ```
4. **實際輸出是：**
   ```markdown
   > 6
   ```
```
