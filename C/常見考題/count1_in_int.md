### **計算整數 `x` 的二進制表示中 `1` 的個數**

#### **代碼分析**
```cpp
#include <iostream>
using namespace std;

int main() {
    int x, c = 0;
    cin >> x;
    while (x > 0) {
        c++;         
        x = x & (x - 1);  // 每次消除最低位的 1
    }
    cout << c << endl;  // 輸出 1 的個數
    return 0;
}
```

---

### **算法解析**
該代碼的目的是計算整數 `x` 在二進制表示中有多少個 `1`。它使用 **Brian Kernighan 算法**，原理如下：

1. `x & (x - 1)` **每次會將 `x` 的最低位 `1` 置為 `0`**。
2. 通過 `while` 循環，每次 `x` 中的 `1` 被消除一次，計數器 `c` 加 `1`。
3. 當 `x` 變為 `0` 時，循環結束，`c` 就是 `1` 的個數。

---

### **示例計算**
假設輸入 `x = 13`，其二進制表示為：
```
13 = 1101₂
```
計算過程如下：

| `x` 初始值 | 二進制表示 | 操作 `x = x & (x - 1)` | 結果 `x` | 計數 `c` |
|------------|------------|----------------|------------|------------|
| 13         | `1101`     | `1101 & 1100`  | `1100`     | 1          |
| 12         | `1100`     | `1100 & 1011`  | `1000`     | 2          |
| 8          | `1000`     | `1000 & 0111`  | `0000`     | 3          |

最終，`c = 3`，表示 `13` 的二進制中有 `3` 個 `1`。

---

### **時間覆雜度**
該算法的 **時間覆雜度為 `O(k)`**，其中 `k` 是 `x` 中 `1` 的個數。相較於傳統的逐位檢查方法（`O(n)`，`n` 為比特位數），這個方法更高效。

---
